# Streaming API Architecture - Class Diagram
# Shows interaction between streaming components and enrichment integration

# Core Streaming Components
StreamingClient: {
  label: "StreamingClient\n(client.py)"
  style: {
    fill: transparent
    stroke: "#2E86AB"
    stroke-width: 2
  }
  
  methods: |md
    + stream_events() -> AsyncGenerator[dict, None]
    + _authenticate() -> bool
    + _parse_stream_event() -> dict
    + _reconnect() -> None
    - _handle_connection_error()
  |
  
  properties: |md
    - config: StreamingConfig
    - session: aiohttp.ClientSession
    - _current_connection: Optional[Connection]
    - _reconnect_attempts: int
  |
}

EventProcessor: {
  label: "EventProcessor\n(event_processor.py)"
  style: {
    fill: transparent
    stroke: "#A23B72"
    stroke-width: 2
  }
  
  methods: |md
    + process_event(event_data: dict) -> None
    + register_event_handler(type: str, handler: Callable)
    + _handle_company_status_change() -> None
    + _validate_event_data() -> bool
    + _get_registered_handler() -> Optional[Callable]
  |
  
  properties: |md
    - event_handlers: dict[str, Callable]
    - _processed_events: int
    - _failed_events: int
  |
}

CompanyStateManager: {
  label: "CompanyStateManager\n(company_state_manager.py)"
  style: {
    fill: transparent
    stroke: "#F18F01"
    stroke-width: 2
  }
  
  methods: |md
    + get_state(company_number: str) -> Optional[dict]
    + update_state(company_number: str, state: str) -> dict
    + queue_status_check(company_number: str) -> str
    + queue_officers_fetch(company_number: str) -> str
    + handle_429_response(company_number, request_id)
    + cleanup_failed_companies() -> int
    + get_processing_metrics() -> dict
  |
  
  properties: |md
    - database_path: str
    - queue_manager: PriorityQueueManager
    - _state_locks: dict[str, asyncio.Lock]
    - _db_lock: asyncio.Lock
    - _initialized: bool
  |
}

PriorityQueueManager: {
  label: "PriorityQueueManager\n(queue_manager.py)"
  style: {
    fill: transparent
    stroke: "#C73E1D"
    stroke-width: 2
  }
  
  methods: |md
    + enqueue(request: QueuedRequest) -> bool
    + dequeue(timeout: float) -> Optional[QueuedRequest]
    + requeue(request: QueuedRequest) -> bool
    + mark_processed(request: QueuedRequest, time: float)
    + mark_failed(request: QueuedRequest)
    + get_queue_status() -> dict
    + clear_queue(priority: Optional[RequestPriority]) -> int
  |
  
  properties: |md
    - max_queue_size: int
    - max_memory_mb: int
    - queues: dict[RequestPriority, deque[QueuedRequest]]
    - active_requests: set[str]
    - metrics: QueueMetrics
    - queue_lock: asyncio.Lock
  |
}

# Enrichment Integration Bridge
StreamingIntegration: {
  label: "StreamingIntegration\n(enrichment/streaming_integration.py)"
  style: {
    fill: transparent
    stroke: "#0F4C75"
    stroke-width: 2
  }
  
  methods: |md
    + handle_strike_off_company_enrichment() -> bool
    + process_webhook_results(payload: dict) -> None
    + _should_enrich_company(company_number: str) -> bool
    + _check_credits_available() -> bool
    + _get_company_officers(company_number: str) -> list
    + _handle_domain_results(payload: dict) -> None
    + _handle_email_results(payload: dict) -> None
    + get_integration_statistics() -> dict
  |
  
  properties: |md
    - company_state_manager: CompanyStateManager
    - queue_manager: PriorityQueueManager
    - credit_manager: Optional[CreditManager]
    - webhook_handler: Optional[WebhookHandler]
    - enrichment_state_manager: EnrichmentStateManager
    - dependency_manager: DependencyManager
  |
}

# Supporting Components
ProcessingState: {
  label: "ProcessingState\n(Enum)"
  style: {
    fill: transparent
    stroke: "#666666"
    stroke-width: 1
  }
  
  states: |md
    DETECTED
    STATUS_QUEUED
    STATUS_FETCHED
    STRIKE_OFF_CONFIRMED
    OFFICERS_QUEUED
    OFFICERS_FETCHED
    COMPLETED
    FAILED
  |
}

QueuedRequest: {
  label: "QueuedRequest\n(DataClass)"
  style: {
    fill: transparent
    stroke: "#666666"
    stroke-width: 1
  }
  
  properties: |md
    - request_id: str
    - priority: RequestPriority
    - endpoint: str
    - params: dict[str, Any]
    - callback: Optional[Callable]
    - created_at: float
    - retry_count: int
    - max_retries: int
  |
}

RequestPriority: {
  label: "RequestPriority\n(IntEnum)"
  style: {
    fill: transparent
    stroke: "#666666"
    stroke-width: 1
  }
  
  values: |md
    HIGH = 1 (Real-time status checks)
    MEDIUM = 2 (Officer fetching)
    LOW = 3 (Bulk operations)
    BACKGROUND = 4 (Maintenance)
  |
}

# Database Tables
Database: {
  label: "SQLite Database\n(companies.db)"
  style: {
    fill: transparent
    stroke: "#8B4513"
    stroke-width: 2
  }
  
  tables: |md
    • companies
    • officers
    • company_processing_state
    • api_rate_limit_log
    • enrichment_state
    • company_domains
    • officer_emails
    • snov_credit_usage
    • snov_webhooks
  |
}

# MAIN WORKFLOW CONNECTIONS
# 1. Streaming to Event Processing
StreamingClient -> EventProcessor: "yields events\nfrom stream_events()"

# 2. Event Processing triggers State Management
EventProcessor -> CompanyStateManager: "calls update_state()\nfor detected companies"

# 3. State Manager uses Queue for API calls
CompanyStateManager -> PriorityQueueManager: "enqueues requests\nvia queue_status_check()\nqueue_officers_fetch()"

# 4. State Manager persists to Database
CompanyStateManager -> Database: "reads/writes\ncompany_processing_state\napi_rate_limit_log"

# 5. Integration Bridge connects to State Management
StreamingIntegration -> CompanyStateManager: "monitors states\nfor strike-off completion"
StreamingIntegration -> PriorityQueueManager: "shares queue for\ncoordination"

# 6. Integration Bridge checks Database
StreamingIntegration -> Database: "reads companies/officers\nwrites enrichment_state"

# SUPPORTING RELATIONSHIPS
# State management dependencies
CompanyStateManager -> ProcessingState: "uses enum\nfor state validation"
PriorityQueueManager -> QueuedRequest: "manages queue\nof requests"
PriorityQueueManager -> RequestPriority: "uses priority\nfor queue ordering"

# Flow annotations
flow_annotation_1: {
  label: "MAIN FLOW:\n1. StreamingClient detects events\n2. EventProcessor handles events\n3. CompanyStateManager tracks processing\n4. PriorityQueueManager handles API calls\n5. StreamingIntegration bridges to enrichment"
  style: {
    fill: "#E8F4FD"
    stroke: "#0066CC"
    stroke-width: 1
  }
}

# Architecture notes
architecture_notes: {
  label: "KEY ARCHITECTURE PRINCIPLES:\n• Zero direct API calls (everything via queue)\n• Bulletproof rate limiting with 429 handling\n• Thread-safe state transitions with asyncio locks\n• Priority-based request processing\n• Database persistence for restart resilience\n• Streaming integration bridge for enrichment workflow"
  style: {
    fill: "#FFF3E0"
    stroke: "#FF6F00"
    stroke-width: 1
  }
}

# Position elements for better layout
StreamingClient -> EventProcessor -> CompanyStateManager -> PriorityQueueManager: {style: {opacity: 0}}
StreamingIntegration -> Database: {style: {opacity: 0}}