"""Integration bridge between streaming service and enrichment components.

This module provides the integration bridge that connects the streaming service
with enrichment components, integrating with the existing _handle_strike_off_company
workflow and queue manager for seamless operation.
"""

import logging
from datetime import datetime
from typing import Any, Dict, Optional

from streaming.company_state_manager import CompanyStateManager
from streaming.queue_manager import PriorityQueueManager
from .credit_aware_workflow import CreditAwareWorkflowCoordinator
from .credit_manager import CreditManager
from .dependency_manager import DependencyManager
from .enrichment_state_manager import EnrichmentState, EnrichmentStateManager
from .snov_client import SnovioClient
from .webhook_handler import WebhookHandler

logger = logging.getLogger(__name__)


class EnrichmentIntegrationError(Exception):
    """Raised when enrichment integration operations fail."""

    pass


class StreamingIntegration:
    """Bridge between streaming service and enrichment components.

    This class provides seamless integration with the existing streaming service,
    connecting all enrichment components and managing the workflow from
    strike-off detection through domain discovery and email finding.
    """

    def __init__(
        self,
        company_state_manager: CompanyStateManager,
        queue_manager: PriorityQueueManager,
        credit_manager: Optional[CreditManager] = None,
        snov_client: Optional[SnovioClient] = None,
        webhook_handler: Optional[WebhookHandler] = None,
        database_path: str = "companies.db",
    ):
        """Initialize streaming integration bridge.

        Args:
            company_state_manager: Existing company state manager
            queue_manager: Existing queue manager
            credit_manager: Credit management component
            snov_client: Snov.io API client for workflow operations
            webhook_handler: Webhook handling component
            database_path: Path to SQLite database

        Raises:
            TypeError: If required components are None
        """
        if not company_state_manager:
            raise TypeError("company_state_manager is required")
        if not queue_manager:
            raise TypeError("queue_manager is required")

        self.company_state_manager = company_state_manager
        self.queue_manager = queue_manager
        self.credit_manager = credit_manager
        self.snov_client = snov_client
        self.webhook_handler = webhook_handler
        self.database_path = database_path

        # Initialize enrichment components
        self.enrichment_state_manager = EnrichmentStateManager(database_path)
        self.dependency_manager = DependencyManager(
            company_state_manager,
            queue_manager,
            database_path,
        )

        # Initialize credit-aware workflow coordinator if we have all required components
        self.credit_aware_workflow: Optional[CreditAwareWorkflowCoordinator] = None
        if credit_manager and snov_client:
            self.credit_aware_workflow = CreditAwareWorkflowCoordinator(
                credit_manager=credit_manager,
                snov_client=snov_client,
                queue_manager=queue_manager,
                enrichment_state_manager=self.enrichment_state_manager,
                database_path=database_path,
            )

        # Statistics tracking
        self.companies_processed = 0
        self.enrichment_initiated = 0
        self.enrichment_completed = 0
        self.enrichment_failed = 0

    async def initialize(self) -> None:
        """Initialize all enrichment components."""
        await self.enrichment_state_manager.initialize()
        logger.info("Streaming integration bridge initialized")

    async def handle_strike_off_company_enrichment(
        self,
        company_number: str,
        company_name: str,
        company_data: Optional[Dict[str, Any]] = None,
    ) -> bool:
        """Handle enrichment for newly detected strike-off company.

        This method executes the complete 10-step credit-aware workflow for
        companies that have been detected as strike-off candidates.

        Args:
            company_number: Companies House company number
            company_name: Company name for domain search
            company_data: Company data from CH REST API (optional)

        Returns:
            True if enrichment workflow was executed successfully
        """
        try:
            self.companies_processed += 1

            # Check if enrichment is eligible
            if not await self._should_enrich_company(company_number):
                logger.debug(f"Company {company_number} not eligible for enrichment")
                return False

            # Use credit-aware workflow if available (new approach)
            if self.credit_aware_workflow:
                logger.info(f"Executing credit-aware workflow for {company_number}")

                # Execute the complete 10-step workflow
                workflow_result = await self.credit_aware_workflow.execute_workflow(
                    company_number=company_number,
                    company_name=company_name,
                    company_data=company_data or {"company_name": company_name},
                )

                # Update enrichment state based on workflow result
                await self._update_enrichment_state_from_workflow(company_number, workflow_result)

                # Count as initiated if workflow started successfully
                if workflow_result["final_status"] != "error":
                    self.enrichment_initiated += 1

                # Count as completed if workflow reached completion
                if workflow_result["final_status"] == "completed":
                    self.enrichment_completed += 1

                return workflow_result["final_status"] != "error"

            # Fallback to legacy approach (backward compatibility)
            logger.warning(
                f"Credit-aware workflow not available, using legacy approach for {company_number}"
            )
            return await self._legacy_enrichment_workflow(company_number, company_name)

        except Exception as e:
            logger.error(f"Error handling enrichment for {company_number}: {e}")
            await self._mark_enrichment_failed(company_number, str(e))
            return False

    async def process_webhook_results(
        self,
        webhook_payload: dict[str, Any],
    ) -> None:
        """Process webhook results from Snov.io API.

        Args:
            webhook_payload: Parsed webhook payload
        """
        try:
            event_type = webhook_payload.get("event_type")

            if event_type == "domain_search_completed":
                await self._handle_domain_results(webhook_payload)
            elif event_type == "email_finder_completed":
                await self._handle_email_results(webhook_payload)
            elif event_type == "credits_updated":
                await self._handle_credits_update(webhook_payload)
            else:
                logger.warning(f"Unknown webhook event type: {event_type}")

        except Exception as e:
            logger.error(f"Error processing webhook results: {e}")

    async def _handle_domain_results(self, payload: dict[str, Any]) -> None:
        """Handle domain search completion results.

        Args:
            payload: Domain search webhook payload
        """
        company_number = payload.get("company_number")
        domains = payload.get("domains", [])
        success = payload.get("success", False)
        request_id = payload.get("request_id")

        if not company_number:
            logger.error("Missing company_number in domain results")
            return

        try:
            # Record credit consumption if available
            if self.credit_manager:
                credits_used = payload.get("credits_consumed", 1)
                await self.credit_manager.record_credit_consumption(
                    "domain_search",
                    credits_used,
                    success,
                    request_id,
                    company_number,
                )

            # Update enrichment state
            if success and domains:
                await self.enrichment_state_manager.update_enrichment_state(
                    company_number,
                    EnrichmentState.DOMAIN_COMPLETED.value,
                    domains_found=len(domains),
                )

                # Continue dependency chain
                await self.dependency_manager.handle_domain_completion(
                    company_number,
                    domains,
                    success,
                )
            else:
                await self.enrichment_state_manager.update_enrichment_state(
                    company_number,
                    EnrichmentState.DOMAIN_FAILED.value,
                    last_error="Domain search failed or no domains found",
                )
                await self._mark_enrichment_failed(company_number, "domain_search_failed")

        except Exception as e:
            logger.error(f"Error handling domain results for {company_number}: {e}")

    async def _handle_email_results(self, payload: dict[str, Any]) -> None:
        """Handle email finder completion results.

        Args:
            payload: Email finder webhook payload
        """
        company_number = payload.get("company_number")
        officer_id = payload.get("officer_id")
        emails = payload.get("emails", [])
        success = payload.get("success", False)
        request_id = payload.get("request_id")

        if not company_number or not officer_id:
            logger.error("Missing company_number or officer_id in email results")
            return

        try:
            # Record credit consumption
            if self.credit_manager:
                credits_used = payload.get("credits_consumed", 1)
                await self.credit_manager.record_credit_consumption(
                    "email_finder",
                    credits_used,
                    success,
                    request_id,
                    company_number,
                    officer_id,
                )

            # Continue dependency chain processing
            await self.dependency_manager.handle_officer_email_completion(
                company_number,
                officer_id,
                emails,
                success,
            )

            # Update enrichment state (simplified - would track individual officers)
            if success:
                current_state = await self.enrichment_state_manager.get_enrichment_state(
                    company_number
                )
                if current_state:
                    emails_found = current_state.get("emails_found", 0) + len(emails)
                    officers_processed = current_state.get("officers_processed", 0) + 1

                    await self.enrichment_state_manager.update_enrichment_state(
                        company_number,
                        EnrichmentState.OFFICERS_COMPLETED.value,
                        emails_found=emails_found,
                        officers_processed=officers_processed,
                    )

                    self.enrichment_completed += 1

        except Exception as e:
            logger.error(f"Error handling email results for {company_number}: {e}")

    async def _handle_credits_update(self, payload: dict[str, Any]) -> None:
        """Handle credits update from webhook.

        Args:
            payload: Credits update webhook payload
        """
        try:
            if self.credit_manager:
                credits_remaining = payload.get("credits_remaining")
                if credits_remaining is not None:
                    await self.credit_manager.update_balance_from_api(credits_remaining)
                    logger.info(f"Updated credit balance: {credits_remaining}")

        except Exception as e:
            logger.error(f"Error handling credits update: {e}")

    async def _should_enrich_company(self, company_number: str) -> bool:
        """Check if company should be enriched.

        Args:
            company_number: Company number to check

        Returns:
            True if company should be enriched
        """
        try:
            # Check if company processing is complete
            company_state = await self.company_state_manager.get_state(company_number)
            if not company_state or company_state["processing_state"] != "completed":
                return False

            # Check enrichment eligibility
            return await self.enrichment_state_manager.is_eligible_for_enrichment(company_number)

        except Exception as e:
            logger.error(f"Error checking enrichment eligibility for {company_number}: {e}")
            return False

    async def _check_credits_available(self) -> bool:
        """Check if sufficient credits are available.

        Returns:
            True if credits are available for operations
        """
        if not self.credit_manager:
            return True  # No credit manager - assume available

        try:
            # Estimate credits needed for domain search
            estimated_credits = 5  # Conservative estimate
            return await self.credit_manager.can_consume_credits(estimated_credits)

        except Exception as e:
            logger.error(f"Error checking credit availability: {e}")
            return False

    async def _queue_officers_fetch_if_needed(self, company_number: str) -> bool:
        """Queue officers fetch from CH REST API if not already in progress.

        This method follows the proper workflow: only fetch officers AFTER
        domain search succeeds, as per the linear diagram.

        Args:
            company_number: Company number to fetch officers for

        Returns:
            True if officers fetch was queued successfully

        Raises:
            Exception: If queue operation fails
        """
        try:
            # Queue officers fetch via CH REST API
            request_id = await self.company_state_manager.queue_officers_fetch(company_number)
            logger.info(
                f"Queued officers fetch for company {company_number}, request_id: {request_id}"
            )
            return True

        except Exception as e:
            logger.error(f"Failed to queue officers fetch for company {company_number}: {e}")
            raise

    async def _mark_enrichment_skipped(self, company_number: str, reason: str) -> None:
        """Mark enrichment as skipped for a company.

        Args:
            company_number: Company number
            reason: Reason for skipping
        """
        try:
            await self.enrichment_state_manager.update_enrichment_state(
                company_number,
                EnrichmentState.ENRICHMENT_SKIPPED.value,
                last_error=f"Skipped: {reason}",
            )

        except Exception as e:
            logger.error(f"Error marking enrichment skipped for {company_number}: {e}")

    async def _mark_enrichment_failed(self, company_number: str, reason: str) -> None:
        """Mark enrichment as failed for a company.

        Args:
            company_number: Company number
            reason: Failure reason
        """
        try:
            self.enrichment_failed += 1

            await self.enrichment_state_manager.update_enrichment_state(
                company_number,
                EnrichmentState.ENRICHMENT_FAILED.value,
                last_error=reason,
            )

        except Exception as e:
            logger.error(f"Error marking enrichment failed for {company_number}: {e}")

    def get_integration_statistics(self) -> dict[str, Any]:
        """Get integration statistics.

        Returns:
            Integration processing statistics
        """
        return {
            "companies_processed": self.companies_processed,
            "enrichment_initiated": self.enrichment_initiated,
            "enrichment_completed": self.enrichment_completed,
            "enrichment_failed": self.enrichment_failed,
            "success_rate": (self.enrichment_completed / max(self.enrichment_initiated, 1) * 100)
            if self.enrichment_initiated > 0
            else 0,
        }

    def get_health_status(self) -> dict[str, Any]:
        """Get integration bridge health status.

        Returns:
            Health status information
        """
        stats = self.get_integration_statistics()

        return {
            "component": "streaming_integration",
            "status": "UP",
            "message": "Streaming integration bridge operational",
            "timestamp": datetime.now().isoformat(),
            "details": {
                **stats,
                "credit_manager_enabled": self.credit_manager is not None,
                "webhook_handler_enabled": self.webhook_handler is not None,
            },
        }

    def get_metrics(self) -> dict[str, Any]:
        """Get integration metrics.

        Returns:
            Metrics data for monitoring
        """
        stats = self.get_integration_statistics()
        metrics = {
            "integration_companies_processed": stats["companies_processed"],
            "integration_enrichment_initiated": stats["enrichment_initiated"],
            "integration_enrichment_completed": stats["enrichment_completed"],
            "integration_enrichment_failed": stats["enrichment_failed"],
            "integration_success_rate": stats["success_rate"],
        }

        # Add credit-aware workflow metrics if available
        if self.credit_aware_workflow:
            workflow_stats = self.credit_aware_workflow.get_workflow_statistics()
            metrics.update(
                {
                    "workflow_credit_aware_started": workflow_stats["workflows_started"],
                    "workflow_credit_aware_completed": workflow_stats["workflows_completed"],
                    "workflow_credit_blocked": workflow_stats["workflows_credit_blocked"],
                    "workflow_domain_searches": workflow_stats["domain_searches_completed"],
                    "workflow_email_searches": workflow_stats["email_searches_completed"],
                    "workflow_success_rate": workflow_stats["success_rate"],
                }
            )

        return metrics

    async def _update_enrichment_state_from_workflow(
        self, company_number: str, workflow_result: Dict[str, Any]
    ) -> None:
        """Update enrichment state based on workflow result.

        Args:
            company_number: Company number
            workflow_result: Result from credit-aware workflow execution
        """
        try:
            final_status = workflow_result.get("final_status", "unknown")

            if final_status == "completed":
                await self.enrichment_state_manager.update_enrichment_state(
                    company_number,
                    EnrichmentState.COMPLETED.value,
                    total_credits_consumed=workflow_result.get("total_credits_consumed", 0),
                )
            elif final_status == "credit_exhausted_before_domain":
                await self.enrichment_state_manager.update_enrichment_state(
                    company_number,
                    EnrichmentState.CREDIT_EXHAUSTED.value,
                    skip_reason="credits_exhausted_before_domain_search",
                )
            elif final_status == "credit_exhausted_before_email":
                await self.enrichment_state_manager.update_enrichment_state(
                    company_number,
                    EnrichmentState.DOMAIN_COMPLETED.value,
                    skip_reason="credits_exhausted_before_email_search",
                )
            elif final_status == "no_domain_found":
                await self.enrichment_state_manager.update_enrichment_state(
                    company_number,
                    EnrichmentState.DOMAIN_FAILED.value,
                    skip_reason="no_domain_found",
                )
            elif final_status == "no_officers_found":
                await self.enrichment_state_manager.update_enrichment_state(
                    company_number,
                    EnrichmentState.OFFICERS_FAILED.value,
                    skip_reason="no_officers_found",
                )
            elif final_status == "error":
                await self.enrichment_state_manager.update_enrichment_state(
                    company_number,
                    EnrichmentState.FAILED.value,
                    error_message=workflow_result.get("error", "workflow_execution_error"),
                )
            else:
                # Set to in-progress for unknown statuses
                await self.enrichment_state_manager.update_enrichment_state(
                    company_number, EnrichmentState.IN_PROGRESS.value, workflow_status=final_status
                )

        except Exception as e:
            logger.error(f"Failed to update enrichment state for {company_number}: {e}")

    async def _legacy_enrichment_workflow(self, company_number: str, company_name: str) -> bool:
        """Legacy enrichment workflow for backward compatibility.

        Args:
            company_number: Company number
            company_name: Company name

        Returns:
            True if enrichment was initiated successfully
        """
        try:
            # Check credit availability using old approach
            if self.credit_manager and not await self._check_credits_available():
                logger.warning("Legacy enrichment skipped due to insufficient credits")
                await self._mark_enrichment_skipped(company_number, "insufficient_credits")
                return False

            # Use old dependency manager approach
            success = await self.dependency_manager.initiate_domain_search_first(
                company_number,
                company_name,
            )

            if success:
                await self.enrichment_state_manager.update_enrichment_state(
                    company_number,
                    EnrichmentState.DOMAIN_QUEUED.value,
                )
                logger.info(f"Legacy domain search initiated for company {company_number}")

            return success

        except Exception as e:
            logger.error(f"Legacy workflow failed for {company_number}: {e}")
            return False
